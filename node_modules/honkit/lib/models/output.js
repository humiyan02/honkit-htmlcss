"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const immutable_1 = __importDefault(require("immutable"));
const parsePageFromString_1 = __importDefault(require("../parse/parsePageFromString"));
const book_1 = __importDefault(require("./book"));
const location_1 = __importDefault(require("../utils/location"));
const Output = immutable_1.default.Record({
    book: book_1.default(),
    // Name of the generator being used
    generator: String(),
    // Map of plugins to use (String -> Plugin)
    plugins: immutable_1.default.OrderedMap(),
    // Map pages to generation (String -> Page)
    pages: immutable_1.default.OrderedMap(),
    // List assets (String)
    assets: immutable_1.default.List(),
    // Option for the generation
    options: immutable_1.default.Map(),
    // Internal state for the generation
    state: immutable_1.default.Map(),
    // incrementalChangeFileSet for incremental building
    // If it is empty, should build all
    incrementalChangeFileSet: immutable_1.default.Set(),
});
Output.prototype.getBook = function () {
    return this.get("book");
};
Output.prototype.getGenerator = function () {
    return this.get("generator");
};
Output.prototype.getPlugins = function () {
    return this.get("plugins");
};
Output.prototype.getPages = function () {
    return this.get("pages");
};
Output.prototype.getOptions = function () {
    return this.get("options");
};
Output.prototype.getAssets = function () {
    return this.get("assets");
};
Output.prototype.getState = function () {
    return this.get("state");
};
/**
 Return a page byt its file path

 @param {String} filePath
 @return {Page|undefined}
 */
Output.prototype.getPage = function (filePath) {
    filePath = location_1.default.normalize(filePath);
    const pages = this.getPages();
    return pages.get(filePath);
};
Output.prototype.reloadPage = function (contentRootDir, filePath) {
    const relativePath = location_1.default.normalize(path_1.default.normalize(path_1.default.relative(contentRootDir, filePath)));
    const pages = this.getPages();
    const page = pages.get(relativePath);
    if (!page) {
        return this;
    }
    const newPage = parsePageFromString_1.default(page, fs_1.default.readFileSync(filePath, "utf-8"));
    return this.merge({
        pages: pages.set(relativePath, newPage),
    });
};
/**
 Get root folder for output

 @return {String}
 */
Output.prototype.getRoot = function () {
    return this.getOptions().get("root");
};
/**
 Update state of output

 @param {Map} newState
 @return {Output}
 */
Output.prototype.setState = function (newState) {
    return this.set("state", newState);
};
/**
 Update options

 @param {Map} newOptions
 @return {Output}
 */
Output.prototype.setOptions = function (newOptions) {
    return this.set("options", newOptions);
};
/**
 Return logegr for this output (same as book)

 @return {Logger}
 */
Output.prototype.getLogger = function () {
    return this.getBook().getLogger();
};
exports.default = Output;
